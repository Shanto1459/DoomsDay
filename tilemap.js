// Resolves tileset image paths relative to a map file.
function resolveMapAssetPath(mapPath, assetPath) {
  if (!assetPath) return assetPath;
  if (/^(?:https?:)?\/\//.test(assetPath)) return assetPath;
  if (assetPath.startsWith("/")) return assetPath;

  const slashIndex = mapPath.lastIndexOf("/");
  if (slashIndex === -1) return assetPath;
  const mapDir = mapPath.slice(0, slashIndex + 1);

  if (assetPath.startsWith("PostApocalypse_AssetPack_v1.1.2/")) {
    return mapDir + "../" + assetPath;
  }

  return mapDir + assetPath;
}

// Resolves map-to-map links (portals) relative to the current map.
function resolveMapPath(mapPath, relativePath) {
  if (!relativePath) return relativePath;
  if (/^(?:https?:)?\/\//.test(relativePath)) return relativePath;
  if (relativePath.startsWith("/")) return relativePath;

  const slashIndex = mapPath.lastIndexOf("/");
  if (slashIndex === -1) return relativePath;
  return mapPath.slice(0, slashIndex + 1) + relativePath;
}

function resolveMapAssetPath(mapPath, assetPath) {
  if (!assetPath) return assetPath;

  assetPath = assetPath.replace(/\\/g, "/");
 
  if (/^(?:https?:)?\/\//.test(assetPath)) return assetPath;
  if (assetPath.startsWith("/")) return assetPath;
  
  const slashIndex = mapPath.lastIndexOf("/");
  const mapDir = slashIndex === -1 ? "" : mapPath.slice(0, slashIndex + 1);
  
  const pack = "PostApocalypse_AssetPack_v1.1.2/";
  const packIdx = assetPath.indexOf(pack);
   if (packIdx !== -1) {
    let cleaned = assetPath.slice(packIdx);

    // ðŸ”¥ REMOVE " - Copy", " - Copy - Copy", etc BEFORE .png
    cleaned = cleaned.replace(/\s-\sCopy.*(?=\.png)/i, "");

    return mapDir + "../" + cleaned;
  }
  const mapsImages = "Maps/images/";
  const mIdx = assetPath.indexOf(mapsImages);
  if (mIdx !== -1) {
    const fileName = assetPath.slice(mIdx + mapsImages.length); // "Garbage_TileSet.png"
    return mapDir + fileName; // matches your correct file style
  }

  return mapDir + assetPath;
}




// Returns map width/height in pixels.
function getMapPixelSize(mapData, scale) {
  const mapScale = scale || 1;
  return {
    width: mapData.width * mapData.tilewidth * mapScale,
    height: mapData.height * mapData.tileheight * mapScale
  };
}

// Finds the default PlayerSpawn object.
function findPlayerSpawn(mapData) {
  if (!mapData || !Array.isArray(mapData.layers)) return null;

  for (const layer of mapData.layers) {
    if (layer.type !== "objectgroup" || !Array.isArray(layer.objects)) continue;

    const layerTypeProp = (layer.properties || []).find(
      (prop) => prop.name === "type" && prop.value === "spawn"
    );

    for (const obj of layer.objects) {
      if (obj.name === "PlayerSpawn") return obj;
      if (layerTypeProp && obj.type === "PlayerSpawn") return obj;
    }
  }

  return null;
}

// Finds a spawn object by name or spawn properties.
function findSpawnByName(mapData, spawnName) {
  if (!mapData || !Array.isArray(mapData.layers)) return null;

  for (const layer of mapData.layers) {
    if (layer.type !== "objectgroup" || !Array.isArray(layer.objects)) continue;
    for (const obj of layer.objects) {
      if (obj.name === spawnName) return obj;
      if (getObjectProperty(obj, "spawn_od") === spawnName) return obj;
      if (getObjectProperty(obj, "spawn") === spawnName) return obj;
    }
  }

  return null;
}

// Returns spawn position in world pixels (scaled).
function getSpawnPosition(mapData, scale, spawnName) {
  let spawn = spawnName ? findSpawnByName(mapData, spawnName) : findPlayerSpawn(mapData);
  if (!spawn) {
    for (const layer of mapData.layers || []) {
      if (layer.type !== "objectgroup" || !Array.isArray(layer.objects)) continue;
      spawn = layer.objects.find((obj) => getObjectProperty(obj, "entity") === "player");
      if (spawn) break;
    }
  }
  if (!spawn) {
    console.warn("Spawn not found:", spawnName || "PlayerSpawn");
    return { x: 0, y: 0 };
  }

  const mapScale = scale || 1;
  return {
    x: spawn.x * mapScale,
    y: spawn.y * mapScale
  };
}

// Helper to read custom object properties from Tiled.
function getObjectProperty(obj, name) {
  if (!obj || !Array.isArray(obj.properties)) return null;
  const prop = obj.properties.find((p) => p.name === name);
  return prop ? prop.value : null;
}

// Detects portal objects based on properties or class/type.
function isPortalObject(obj) {
  const typeProp = getObjectProperty(obj, "type");
  if (typeProp === "portal") return true;
  if (obj.type === "portal") return true;
  if (obj.class === "portal") return true;
  if (getObjectProperty(obj, "targetMap")) return true;
  if (getObjectProperty(obj, "targetSpawn")) return true;
  return false;
}

// Collects all portal objects from every object layer.
function getPortalObjects(mapData) {
  if (!mapData || !Array.isArray(mapData.layers)) return [];
  const portals = [];

  for (const layer of mapData.layers) {
    if (layer.type !== "objectgroup" || !Array.isArray(layer.objects)) continue;
    for (const obj of layer.objects) {
      if (isPortalObject(obj)) portals.push(obj);
    }
  }

  return portals;
}

// Collects all tileset image paths used by a map.
function collectTilesetImagePaths(mapData, mapPath) {
  if (!mapData || !Array.isArray(mapData.tilesets)) return [];
  const paths = new Set();

  for (const tileset of mapData.tilesets) {
    const tilesetPath = resolveMapAssetPath(mapPath, tileset.image);
    if (tilesetPath) paths.add(tilesetPath);

    for (const tile of tileset.tiles || []) {
      const tilePath = resolveMapAssetPath(mapPath, tile.image);
      if (tilePath) paths.add(tilePath);
    }
  }

  return [...paths];
}

// Preloads images and stores them in the asset cache.
function preloadImages(paths) {
  const uniquePaths = [...new Set(paths)].filter(Boolean);
  if (uniquePaths.length === 0) return Promise.resolve({ loaded: 0, failed: 0 });

  let loaded = 0;
  let failed = 0;

  return Promise.all(
    uniquePaths.map(
      (path) =>
        new Promise((resolve) => {
          const img = new Image();
          img.addEventListener("load", () => {
            ASSET_MANAGER.cache[path] = img;
            loaded += 1;
            resolve();
          });
          img.addEventListener("error", () => {
            failed += 1;
            console.warn("Failed to load image:", path);
            resolve();
          });
          img.src = path;
        })
    )
  ).then(() => ({ loaded, failed }));
}

class CollisionGrid {
  constructor(mapData, scale, collisionLayerName) {
    this.mapData = mapData;
    this.scale = scale || 1;
    this.collisionLayerName = collisionLayerName || "Collision";
    this.collisionLayer = this.findCollisionLayer();
  }

  // Finds the tile layer named "Collision".
  findCollisionLayer() {
    if (!this.mapData || !Array.isArray(this.mapData.layers)) return null;
    return this.mapData.layers.find(
      (layer) => layer.type === "tilelayer" && layer.name === this.collisionLayerName
    );
  }

  // Checks if a rectangle overlaps any blocked tiles.
  isBlockedRect(x, y, width, height) {
    if (!this.collisionLayer || !Array.isArray(this.collisionLayer.data)) return false;
    const tileWidth = this.mapData.tilewidth * this.scale;
    const tileHeight = this.mapData.tileheight * this.scale;

    const left = Math.floor(x / tileWidth);
    const right = Math.floor((x + width - 1) / tileWidth);
    const top = Math.floor(y / tileHeight);
    const bottom = Math.floor((y + height - 1) / tileHeight);

    for (let ty = top; ty <= bottom; ty++) {
      for (let tx = left; tx <= right; tx++) {
        if (this.isBlockedTile(tx, ty)) return true;
      }
    }

    return false;
  }

  // Checks a single tile for collision.
  isBlockedTile(tx, ty) {
    if (!this.collisionLayer) return false;
    if (tx < 0 || ty < 0 || tx >= this.collisionLayer.width || ty >= this.collisionLayer.height) {
      return true;
    }
    const index = ty * this.collisionLayer.width + tx;
    return this.collisionLayer.data[index] !== 0;
  }
}

class TiledMapRenderer {
  constructor(game, mapData, mapPath, scale) {
    this.game = game;
    this.mapData = mapData;
    this.mapPath = mapPath;
    this.scale = scale || 1;
    this.missingImages = new Set();
    this.tilesets = (mapData.tilesets || []).map((tileset) => ({
      ...tileset,
      imagePath: resolveMapAssetPath(mapPath, tileset.image),
      tileImageMap: (tileset.tiles || []).reduce((acc, tile) => {
        if (tile.image) {
          acc[tile.id] = {
            imagePath: resolveMapAssetPath(mapPath, tile.image),
            width: tile.imagewidth,
            height: tile.imageheight
          };
        }
        return acc;
      }, {})
    }));
  }

  update() {}

  // Draws all visible tile layers.
  // Draws only the tiles visible in the camera view (culling).
draw(ctx) {
  const game = this.game;

  const tileW = this.mapData.tilewidth * this.scale;
  const tileH = this.mapData.tileheight * this.scale;

  // Camera/view rectangle in WORLD coordinates
  const viewLeft = game.camera?.x || 0;
  const viewTop = game.camera?.y || 0;
  const viewRight = viewLeft + ctx.canvas.width;
  const viewBottom = viewTop + ctx.canvas.height;

  // Draw a small buffer to avoid popping at edges
  const bufferTiles = 1;

  // Convert view rect -> tile indices
  const startCol = Math.max(0, Math.floor(viewLeft / tileW) - bufferTiles);
  const endCol = Math.min(this.mapData.width - 1, Math.floor(viewRight / tileW) + bufferTiles);

  const startRow = Math.max(0, Math.floor(viewTop / tileH) - bufferTiles);
  const endRow = Math.min(this.mapData.height - 1, Math.floor(viewBottom / tileH) + bufferTiles);


  console.log("Tiles range:", startRow, endRow, startCol, endCol);

  for (const layer of this.mapData.layers) {
    if (layer.type !== "tilelayer" || !layer.visible) continue;
    if (!Array.isArray(layer.data)) continue;

    // If a layer has its own width/height, use it; otherwise map size
    const layerW = layer.width || this.mapData.width;

    for (let row = startRow; row <= endRow; row++) {
      for (let col = startCol; col <= endCol; col++) {
        const i = row * layerW + col;
        const rawGid = layer.data[i];          // may include rotate/flip bits
        const gid = rawGid & 0x1FFFFFFF;       // strip Tiled flags
        if (gid === 0) continue;

        const tileset = this.getTilesetForGid(gid);
        if (!tileset) continue;

        const tileIndex = gid - tileset.firstgid;

        const destX = col * tileW;
        const destY = row * tileH;

        const flipH = (rawGid & 0x80000000) !== 0;
        const flipV = (rawGid & 0x40000000) !== 0;
        const flipD = (rawGid & 0x20000000) !== 0;

        // --- Normal tileset image (spritesheet)
        if (tileset.imagePath) {
          const columns = tileset.columns;
          const srcX = (tileIndex % columns) * tileset.tilewidth;
          const srcY = Math.floor(tileIndex / columns) * tileset.tileheight;

          const image = ASSET_MANAGER.getAsset(tileset.imagePath);
          if (!image) {
            if (!this.missingImages.has(tileset.imagePath)) {
              console.warn("Missing tileset image:", tileset.imagePath);
              this.missingImages.add(tileset.imagePath);
            }
            continue;
          }

          const dw = tileset.tilewidth * this.scale;
          const dh = tileset.tileheight * this.scale;

          ctx.save();
          ctx.translate(destX + dw / 2, destY + dh / 2);

          // Tiled: apply diagonal first, then H/V
          if (flipD) {
            ctx.rotate(Math.PI / 2);
            ctx.scale(-1, 1);
          }
          if (flipH) ctx.scale(-1, 1);
          if (flipV) ctx.scale(1, -1);

          ctx.drawImage(
            image,
            srcX,
            srcY,
            tileset.tilewidth,
            tileset.tileheight,
            -dw / 2,
            -dh / 2,
            dw,
            dh
          );

          ctx.restore();


        // --- Per-tile images (image collection tileset)
        } else if (tileset.tileImageMap && tileset.tileImageMap[tileIndex]) {
          const tileImage = tileset.tileImageMap[tileIndex];
          const image = ASSET_MANAGER.getAsset(tileImage.imagePath);
          if (!image) {
            if (!this.missingImages.has(tileImage.imagePath)) {
              console.warn("Missing tile image:", tileImage.imagePath);
              this.missingImages.add(tileImage.imagePath);
            }
            continue;
          }

          const dw = tileImage.width * this.scale;
          const dh = tileImage.height * this.scale;

          ctx.save();
          ctx.translate(destX + dw / 2, destY + dh / 2);

          if (flipD) {
            ctx.rotate(Math.PI / 2);
            ctx.scale(-1, 1);
          }
          if (flipH) ctx.scale(-1, 1);
          if (flipV) ctx.scale(1, -1);

          ctx.drawImage(image, -dw / 2, -dh / 2, dw, dh);
          ctx.restore();

        }
      }
    }
  }
}


  getTilesetForGid(gid) {
    let selected = null;
    for (const tileset of this.tilesets) {
      if (gid >= tileset.firstgid) selected = tileset;
    }
    return selected;
  }
}

function walkLayers(layers, fn) {
  if (!Array.isArray(layers)) return;
  for (const layer of layers) {
    fn(layer);
    // Tiled group layers store children in `layers`
    if (layer.type === "group" && Array.isArray(layer.layers)) {
      walkLayers(layer.layers, fn);
    }
  }
}

function collectDialogueTriggers(mapData, mapScale) {
  const triggers = [];

  walkLayers(mapData.layers, (layer) => {
    if (layer.type !== "objectgroup") return;

    for (const obj of layer.objects || []) {
      const isDialogue =
        getObjectProperty(obj, "type") === "dialogue" ||
        obj.type === "dialogue" ||
        obj.class === "dialogue";

      if (!isDialogue) continue;

      triggers.push({
        group: getObjectProperty(obj, "group") || obj.name || "(no group)",
        text: getObjectProperty(obj, "text") || "",
        once: !!getObjectProperty(obj, "once"),
        rect: {
          x: obj.x * mapScale,
          y: obj.y * mapScale,
          width: (obj.width || mapData.tilewidth) * mapScale,
          height: (obj.height || mapData.tileheight) * mapScale
        }
      });
    }
  });

  return triggers;
}


class MapManager {
  constructor(game, player, mapScale) {
    this.game = game;
    this.player = player;
    this.mapScale = mapScale || 1;
    this.mapData = null;
    this.mapPath = "";
    this.renderer = null;
    this.collisionGrid = null;
    this.portals = [];
    this.portalCooldown = 0;
    this.activePortalId = null;
    this.isTransitioning = false;
  }

  // Applies a new map, builds collisions/portals, and moves the player.
  setMap(mapData, mapPath, spawnName) {
    console.log("MAP LOADED NAME:", mapData?.properties);
    console.log(
  "LAYER NAMES:",
  mapData.layers.map(l => `${l.name} (${l.type})`)
);

    this.mapData = mapData;
    this.mapPath = mapPath;
    this.renderer = new TiledMapRenderer(this.game, mapData, mapPath, this.mapScale);
    this.collisionGrid = new CollisionGrid(mapData, this.mapScale, "Collision");
    this.portals = getPortalObjects(mapData);

    // --- Dialogue triggers from Tiled ---
    this.dialogueTriggers = [];
    this.dialogueUsedGroups = new Set();

    for (const layer of mapData.layers) {
    if (layer.type !== "objectgroup") continue;

    for (const obj of layer.objects || []) {
    const marker =
    getObjectProperty(obj, "type") ||
    obj.class ||
    obj.type ||
    obj.name;

    const isDialogue = marker === "dialogue";

  if (isDialogue) {
    console.log("FOUND DIALOGUE OBJECT:", obj);
  }




    if (isDialogue) {
      this.dialogueTriggers.push({
      group: getObjectProperty(obj, "group") || obj.name || `obj-${obj.id}`,
      text: getObjectProperty(obj, "text") || "(missing text property)",
      once: getObjectProperty(obj, "once") ?? true,
        rect: {
          x: obj.x * this.mapScale,
          y: obj.y * this.mapScale,
          width: (obj.width || mapData.tilewidth) * this.mapScale,
          height: (obj.height || mapData.tileheight) * this.mapScale
        }
      });
    console.log("FINAL dialogue triggers:", this.dialogueTriggers);

    }
  }
}


    const mapSize = getMapPixelSize(mapData, this.mapScale);
    this.game.worldWidth = mapSize.width;
    this.game.worldHeight = mapSize.height;
    this.game.collisionGrid = this.collisionGrid;

    const spawn = getSpawnPosition(mapData, this.mapScale, spawnName);
    this.player.x = spawn.x;
    this.player.y = spawn.y;

    console.log("Map loaded:", mapPath);
    console.log("Spawn:", spawnName || "PlayerSpawn", spawn);
    this.logObjectLayers();
    this.logPortals();
    this.logSpawns();
  }

  // Loads the next map from a portal object.
  async transitionTo(portal) {
    if (this.isTransitioning) return;
    const targetMap = getObjectProperty(portal, "targetMap");
    const targetSpawn = getObjectProperty(portal, "targetSpawn");
    if (!targetMap) return;

    this.isTransitioning = true;
    console.log("Portal triggered:", portal.name || "(unnamed)", targetMap, targetSpawn);

    const nextMapPath = resolveMapPath(this.mapPath, targetMap);
    const fetchPath = encodeURI(nextMapPath);
    try {
      console.log("Fetching map:", fetchPath);
      const response = await fetch(fetchPath + "?v=" + Date.now());
      if (!response.ok) throw new Error(`Map fetch failed: ${response.status}`);
      const mapData = await response.json();

      const tilePaths = collectTilesetImagePaths(mapData, nextMapPath);
      const result = await preloadImages(tilePaths);
      console.log("Tileset images loaded:", result.loaded, "failed:", result.failed);

      this.setMap(mapData, nextMapPath, targetSpawn);
      this.portalCooldown = 0.5;
      this.activePortalId = portal.id;
    } catch (error) {
      const altMap = targetMap.includes("_") ? targetMap.replace(/_/g, " ") : null;
      if (altMap) {
        const altPath = resolveMapPath(this.mapPath, altMap);
        const altFetchPath = encodeURI(altPath);
        try {
          console.warn("Retrying map with spaces:", altFetchPath);
          const retry = await fetch(altFetchPath);
          if (!retry.ok) throw new Error(`Map fetch failed: ${retry.status}`);
          const mapData = await retry.json();
          const tilePaths = collectTilesetImagePaths(mapData, altPath);
          const result = await preloadImages(tilePaths);
          console.log("Tileset images loaded:", result.loaded, "failed:", result.failed);
          this.setMap(mapData, altPath, targetSpawn);
          this.portalCooldown = 0.5;
          this.activePortalId = portal.id;
        } catch (retryError) {
          console.error("Failed to load map:", nextMapPath, retryError);
        }
      } else {
        console.error("Failed to load map:", nextMapPath, error);
      }
    } finally {
      this.isTransitioning = false;
    }
  }

  // Checks portal overlap each frame.
 update() {
  if (!this.mapData) return;

  if (this.portalCooldown > 0) {
    this.portalCooldown -= this.game.clockTick;
  }

  const playerBounds = this.player.getBounds();

  // --- portal logic ---
  for (const portal of this.portals) {
    const portalRect = this.getPortalRect(portal);
    const overlap = rectsOverlap(playerBounds, portalRect);

    if (!overlap && this.activePortalId === portal.id) {
      this.activePortalId = null;
    }

    if (overlap && this.portalCooldown <= 0 && this.activePortalId !== portal.id) {
      console.log("Portal overlap detected:", portal.name || "(unnamed)", portalRect);
      this.transitionTo(portal);
      break;
    }
  }

  // --- dialogue logic (REUSE same playerBounds) ---
  for (const trigger of this.dialogueTriggers || []) {
    if (trigger.once && this.dialogueUsedGroups.has(trigger.group)) continue;

    if (rectsOverlap(playerBounds, trigger.rect)) {
      this.game.showDialogue(trigger.text);
      if (trigger.once) {
        this.dialogueUsedGroups.add(trigger.group);
      }
      break;
    }
  }
}

    

    


  // Draws the map (behind entities).
  draw(ctx) {
    if (!this.renderer) return;
    this.renderer.draw(ctx);
  }

  // Converts a portal object into a screen-space rectangle.
  getPortalRect(portal) {
    const tileWidth = this.mapData.tilewidth;
    const tileHeight = this.mapData.tileheight;
    const width = portal.width || tileWidth;
    const height = portal.height || tileHeight;
    return {
      x: portal.x * this.mapScale,
      y: portal.y * this.mapScale,
      width: width * this.mapScale,
      height: height * this.mapScale
    };
  }

  // Debug: log object layer counts.
  logObjectLayers() {
    if (!this.mapData || !Array.isArray(this.mapData.layers)) return;
    const objectLayers = this.mapData.layers.filter((l) => l.type === "objectgroup");
    const objectCount = objectLayers.reduce((sum, l) => sum + (l.objects ? l.objects.length : 0), 0);
    console.log("Object layers:", objectLayers.length, "objects:", objectCount);
  }

  // Debug: log portal objects.
  logPortals() {
    if (!this.portals) return;
    console.log("Portals found:", this.portals.length);
    for (const portal of this.portals) {
      console.log("Portal:", {
        name: portal.name,
        x: portal.x,
        y: portal.y,
        width: portal.width,
        height: portal.height,
        properties: portal.properties || []
      });
    }
  }

  // Debug: log spawn objects.
  logSpawns() {
    if (!this.mapData || !Array.isArray(this.mapData.layers)) return;
    const spawns = [];
    for (const layer of this.mapData.layers) {
      if (layer.type !== "objectgroup" || !Array.isArray(layer.objects)) continue;
      for (const obj of layer.objects) {
        if (obj.name && obj.name.toLowerCase().includes("spawn")) {
          spawns.push(obj.name);
        } else if (getObjectProperty(obj, "entity") === "player") {
          spawns.push(obj.name || "(unnamed player spawn)");
        }
      }
    }
    console.log("Spawn objects:", spawns.length ? spawns : "none found");
  }
}

function rectsOverlap(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}
